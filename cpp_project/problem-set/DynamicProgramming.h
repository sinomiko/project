#include <iostream>  
using namespace std;  
/**
https://blog.csdn.net/misayaaaaa/article/details/71940779

动态规划的详细知识点请参考：http://blog.csdn.net/misayaaaaa/article/details/71794620

动态规划算法的难点在于 从实际问题中抽象出动态规划表dp，dp一般是一个数组，
可能是一维的也可能是二维的，也可能是其他的数据结构：
整个求解过程就可以用一个最优决策表来描述，最优决策表可以是一个二维表，
其中行表示决策的阶段，列表示问题状态，
表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），
填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，
最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解：

f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}

最简单的台阶问题：有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法？

由分析可知：n阶台阶，只可能是从n-1或是n-2的台阶上走上来的，
台阶n的阶段依赖的是n-1和n-2的子阶段，
所以状态转移方程为dp[n] = dp[n-1] + dp[n-2]，属于最简单的动态规划问题

 */
#define N 20        //台阶数为20  
int dp[N];          //全局数组，存放决策表  
int fun(int n)      //返回台阶数为n的走法  
{  
    if (n == 1 || n == 2)  
    {  
        return n;  
    }  
    dp[n-1] = fun(n-1);        //若不为1或2则进行递归计算  
    dp[n-2] = fun(n-2);  
    dp[n] = dp[n-1]+dp[n-2];   //状态转移方程  
    return dp[n];  
}  
/**
最短路径问题：给定一个矩阵m，从左上角开始每次只能向右走或者向下走，
最后达到右下角的位置，路径中所有数字累加起来就是路径和，
返回所有路径的最小路径和，如果给定的m如下，
那么路径1,3,1,0,6,1,0就是最小路径和，返回12.


1 3 5 9
8 1 3 4
5 0 6 1
8 8 4 0

由分析可知：走到第(i ,j)个数时，只可能是从(i-1 ,j)或是(i ,j-1)走来的，
路径(i ,j)的阶段依赖的是(i-1 ,j)和(i ,j-1)的子阶段，
所以状态转移方程为

dp[i][j] =a[i][j] + min(dp[i-1][j]+ dp[i][j-1])

属于简单的动态规划问题
 */
 #include <algorithm> 
 #define LEN 4
 int dp2[4][4] = {};     //全局数组，存放决策表 
 void ShortestDistance()
 {
	int a[4][4] = {1,3,5,9,8,1,3,4,5,0,6,1,8,8,4,0};  //矩阵存储a[i][j]  
    for (int i = 0;i < 4;++i)  
    {  
        for (int j = 0;j < 4;++j)  
        {  
            if (i==0 && j==0)                         //边界条件问题需要考虑到  
            {  
                dp2[i][j] = a[i][j];  
            }  
            else if (i==0 && j!=0)  
            {  
                dp2[i][j] = a[i][j] + dp2[i][j-1];  
            }  
            else if (i!=0 && j==0)  
            {  
                dp2[i][j] = a[i][j] + dp2[i-1][j];  
            }  
            else  
            {  
                dp2[i][j] = a[i][j] + min(dp2[i-1][j],dp2[i][j-1]);  
            }  
        }  
    }  
  
    cout<<"走到位置"<<"(4,4)"<<"最短路径为：";  
    cout<<dp2[3][3]<<endl;           //好像到这里又脑残了一次，真输出dp[4][4]了~  
 }

int testDP()
{  
    fun(N);  
    cout<<dp[15]<<endl;        //输出15阶的走法  
	
	ShortestDistance();
    system("pause");  
    return 0;  
}  